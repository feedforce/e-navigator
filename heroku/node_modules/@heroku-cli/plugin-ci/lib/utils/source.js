'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const got = require('got');
const git = require('./git');
const fs = require("async-file");
const cli_ux_1 = require("cli-ux");
async function uploadArchive(url, filePath) {
    const request = got.stream.put(url, {
        headers: {
            'content-length': (await fs.stat(filePath)).size
        }
    });
    fs.createReadStream(filePath).pipe(request);
    return new Promise((resolve, reject) => {
        request.on('error', reject);
        request.on('response', resolve);
    });
}
async function prepareSource(ref, command) {
    const filePath = await git.createArchive(ref);
    const { body: source } = await command.heroku.post('/sources');
    await uploadArchive(source.source_blob.put_url, filePath);
    return Promise.resolve(source);
}
async function urlExists(url) {
    return got.head(url);
}
async function createSourceBlob(ref, command) {
    try {
        const githubRepository = await git.githubRepository();
        const { user, repo } = githubRepository;
        let { body: archiveLink } = await command.heroku.get(`https://kolkrabbi.heroku.com/github/repos/${user}/${repo}/tarball/${ref}`);
        if (await urlExists(archiveLink.archive_link)) {
            return archiveLink.archive_link;
        }
    }
    catch (ex) {
        // the commit isn't in the repo, we will package the local git commit instead
        cli_ux_1.ux.debug(`Commit not found in pipeline repository: ${ex}`);
    }
    const sourceBlob = await prepareSource(ref, command);
    return sourceBlob.source_blob.get_url;
}
exports.createSourceBlob = createSourceBlob;
